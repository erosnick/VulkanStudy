[TOC]

# Introduction

## About
## 关于

这份Vulkan教程将教会你使用Vulkan图形和计算API的基础。Vulkan是由Khronos组织(因OpenGL而闻名)发布的新API，它提供了对现代显卡更好的抽象。新的接口允许你更好的描述程序的意图，和现存API如OpenGL和Direct3D(指Direct3D 12之前的版本)相比较会获得更好的性能以及更少的意料之外的驱动行为。Vulkan背后的思想和Direct3D 12和Metal类似，不过Vulkan的优势是完全跨平台的，让你能够同时为Windows, Linux和Android开发。

不过，你要为这些收益付出的代价是，使用更加冗长繁琐的API。和图形API有关的任何细节都需要程序从头开始设置，包括帧缓冲创建以及缓冲和纹理对象的内存管理。图形驱动插手的程度会少很多，这意味着你要做更多的工作来保证程序的行为正确。

结论是Vulkan不适合所有人。它的目标群体是对高性能计算机图形学满怀热情(enthusiastic about)的传火者，并且愿意为之进行献祭。如果你对游戏开发更感兴趣，你可能更愿意死磕OpenGL或Direct3D，它们并不会因为Vulkan的光芒在短时间内消亡。另一个选择是使用Unreal Engine或Unity，在能够使用Vulkan的同时给你提供更高层的API。

热身到此为止，让我们看看这份教程所需的前置知识：

* 一块支持Vulkan的显卡以及对应驱动(NVIDIA, AMD, Intel)。
* 有C++经验(熟悉RAII，初始化列表)。
* 一款支持C++11的编译器(Visual Studio 2013+, GCC 4.8+)。
* 一些3D计算机图形学经验。

这份教程不会假设你有OpenGL或Direct3D相关概念的知识，但是确实需要你有3D计算机图形学的基础。举个栗子，这里不会解释透视投影背后的数学原理。参考这本在线书籍[Learning Modern 3D Graphics Programming](<https://paroj.github.io/gltut/>)来获得很好的计算图形学概念介绍。其他一些很棒的计算机图形学资源是：

* Ray tracing in one weekend
* Physically Based Rendering
* 使用Vulkan的真实引擎，开源的vkQuake和vkNeo(加入VUlkan渲染器的Doom3)

如果愿意的话你可以用C代替C++，不过你得用其他线性代数库并自己组织代码结构。我们会使用C++的类和RAII特性来组织逻辑和资源生命周期。

为了让使用其他编程语言的开发者更容易跟进，并获得一些基础API的经验，我们会使用原始的C API来和Vulkan打交道。如果你使用C++，可能更愿意使用新的Vulkan-Hpp绑定，它抽象了一些脏活来避免某种类型的错误。

## Tutorial structure

## 教程结构

我们首先从Vulkan的概述以及画一个三角形之前要做的工作开始。在了解了每个步骤在整个过程中的基本职责之后，它们的作用才变得更有意义。接下来，我们会使用Vulkan SDK建立开发环境，使用GLM库进行数学运算，使用GLFW进行窗口创建。

之后我们会实现绘制第一个三角形的所有必须组件。每个章节大致按照下面的结构组织：

* 介绍新的概念和它的作用
* 使用所有相关的API来基成到现有程序种
* 将它的部分抽象为帮助函数

尽管每一章都是作为上一章的后续而编写的，也可以将这些章节当作介绍Vulkan某个特性的独立文章来阅读。这意味着网站作为引用也是很有帮助的。所有Vulkan函数和类型都链接到技术规范，你可以点进去学习更详细的内容。

就像之前说的，Vulkan API相当的繁琐，它带有很多参数让你对图形硬件的控制最大化。这导致像是创建纹理之类的基本操作需要很多步骤，并且每次都要重复。因此在教程的进行过程中我们会创建自己的帮助函数。

每章的结尾也会包含到目前为止的完整代码。如果你对代码结构有任何疑惑，可以进行参考，或者只是遇到Bug想要对比一下差异。所有代码都在多个品牌的图形硬件上测试以保证其正确性。

当你经历所有仪式的洗礼，让Vulkan原力驱动的三角形呈现于屏幕之际，我们会扩展程序来包含线性变换，纹理和3D模型。

如果你以前把玩过图形API，你会清楚的知道在屏幕显示第一个几何体之前要经历很多步骤。Vulkan中这样的步骤也有很多，但是每个步骤都很容易理解，并且不会觉得是多余的。还有要记住很重要的一点，绘制一个带纹理的3D模型不会比绘制一个枯燥三角形所需的工作更多，并且往后每进步一点都变得更有意义。

准备好进入触及未来的高性能图形API的苦难之旅了吗？走起。



