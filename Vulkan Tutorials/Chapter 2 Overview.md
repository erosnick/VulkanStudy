[TOC]

# Overview

# 概述

这章会对介绍Vulkan以及它解决的问题。再这之后我们会看看炼成第一个三角形所需的原料。将会为你提供一个后续章节的整体图景。

## Origin of Vulkan
## Vulkan的起源

和先代图形API一样，Vulkan设计为跨平台的GPU抽象。问题是这些API设计的年代，图形硬件受限于可配置的固定功能管线。程序员必须用标准的格式提供顶点数据，关于光照和着色的选项也受制于GPU制造商。

随着显卡架构的成熟，它们开始提供更多的可编程功能。所有新功能必须集成到现有的API。这导致不理想的抽象，图形驱动需要做很多猜想来将程序员的意图映射到现代图形架构。这就是为啥驱动频繁的更新来提升游戏性能，有时提升幅度还挺大。因为这些驱动的复杂性，程序员还需要处理不同品牌之间的不一致性，比如Shader的语法。抛开这些新特性不谈，过去的10年带有高性能图形硬件的移动设备大量出现。这些移动GPU因为能源和空间需求有不同的架构，一个例子是Tiled Rendering，通过为程序员提供对该功能的更多控制能够从性能提升中获益。另一个源于这些API年代久远的限制是很有限的多线程支持，这回导致CPU端的瓶颈。

Vulkan通过为现代图形架构量身定做来解决这些问题。它允许程序员通过更繁琐的API来清楚的表明自己的意图来减少驱动消耗，允许多线程并行的创建和提交命令。通过切换到带单一编译器的标准化字节码格式来消除Shader编译的不一致性。

## What it takes to draw a triangle
## 画一个三角形需要什么？

现在我们来看看在一个行为良好的Vulkan程序中绘制一个三角形所需的所有步骤。这里介绍的所有概念都会在后续章节中详细说明，现在只是给你一个所有相关组件的整体印象。

### Step 1 - Instance and physical device selection
### 步骤 1 - 实例和物理设备选择

一个Vulkan程序从通过VkInstance对象设置Vulkan API开始。实例通过你对应用程序的描述和要使用的所有API扩展进行创建。创建好实例之后，你 可以查询Vulkan支持的硬件来选择一个或多个VkPhysicalDevice来进行操作。你可以查询VRAM尺寸(显存)和设备能力来选择想要的设备，比如说想要使用专用的显卡。

### Step 2 - Logical device and queue families
### 步骤 2 - 逻辑设备和队列家族

选择了正确的硬件设备之后，你需要创建VkDevice(逻辑设备)，这里你会更详细的指定想要使用哪些物理设备特性，比如多视口渲染和64位浮点数。你还要指定要用哪个队列家族。大多数Vulkan执行的操作，像是渲染命令和内存操作，都通过提交到VkQueue进行同步的(asynchronously)执行。队列从队列家族分配，队列家族支持一个特定的操作集合。例如，可能会有单独的队列用于图形，计算和内存移动操作。队列家族的可用性也是物理设备选择时的一个区别因素，不过今天支持Vulkan的所有显卡一般支持所有我们感兴趣的队列操作。

### Step 3 - Window surface and swap chain
### 步骤 3 - 窗口表面和交换链

除非你只对离屏渲染感兴趣，否则需要创建一个窗口来呈现渲染图像。Windows可以通过原生API或GLFW/SDL库来创建创建。本教程中我们会使用GLFW。

我们需要另外两个组件来实际的渲染到窗口：一个窗口表面(VkSurfaceKHR)，和一个交换链(VkSwapchainKHR)。注意KHR后缀，意味着这些对象属于Vulkan扩展。 Vulkan API本身是完全平台无关的。这就是为什么我们需要使用标准化的WSI(Window System Interface)扩展来和窗口管理器交互。Surface本身是一个跨平台的渲染窗口抽象，通常使用一个原生窗口句柄来初始化，比如Windows平台的HWND。幸运的是，GLFW库帮你处理了这些细节。

注：下文中提到的图像(原文是image)，尤其是上下文存在交换链的时候，指代常规3D图形学概念中的离屏缓冲(颜色缓冲，深度缓冲，模板缓冲)，和代表纹理的图片(也称为image)有本质区别。

交换链是一组渲染目标的集合(Render Target)。它的基本目的是保证当前正在渲染的图像和屏幕上看到的图像是不同的。这一点很重要，可以保证只有完整的图像被显示。每次我们想要绘制一帧需要交换链为我们提供一张用于渲染的图像(画布)。当我们完成一帧的绘制，图像回到交换链以便在某个时候呈现到屏幕。渲染目标的数量和呈现图像到屏幕的条件取决于呈现模式。常见的呈现模式是双缓冲(vsync，垂直同步)和三缓冲。

有些平台允许你通过VK_KHR_display和VK_KHR_display_swapchain扩展直接渲染到屏幕而不用和任何窗口管理器打交道。这些扩展让你可以创建代表整个屏幕的表面，并实现自己的窗口管理器。

### Step 4 - Image views and framebuffers
### 步骤 4 - 图像视图和帧缓冲

要绘制到从交换链获取的图像，我们需要将它包装成VkImageView和VkFramebuffer。图像视图引用了图像的特定部分，帧缓冲引用用作颜色(color)，深度(depth)和模板(stencil)的图像视图。因为交换链中可以有很多图像，我们需要为每一个创建图像视图和帧缓冲，然后在绘制的时候选择正确的那个。

### Step 5 - Render passes
步骤5 - 渲染阶段

Vulkan中的渲染阶段描述渲染操作中的图像类型，它们如何被使用，已经它们的内容如何被对待。在我们最初的三角形渲染程序中，我们告诉Vulkan使用单一的图像来作为颜色目标(color target)，并且我们想在渲染之前将它清除为纯色。渲染阶段仅仅描述了图像的类型，VkFramebuffer将特定的图像绑定到这些槽(slot，指前面说的color, depth, stencil)。

### Step 6 - Graphics pipeline
### 步骤 6 - 图形管线

Vulkan中的图形管线通过创建一个VkPipeline对象来设置。它描述了显卡的可配置状态，比如视口尺寸，深度缓冲操作以及使用VkShaderModule对象的可编程状态。VkShaderModule对象从Shader字节码创建。驱动还需要知道哪个渲染目标会在管线中使用，我们通过引用渲染阶段来指定。

Vulkan和现有API相比最独特的一点是，几乎所有图形管线的配置需要预先完成。这意味着如果你想要切换到一个不同的Shader或微调顶点布局，你需要整个重新创建图形管线，也就是说你需要预先创建很多VkPipeline对象来满足渲染操作的不同组合需求。只有一些基本的配置，像是视口尺寸和清除颜色能够动态的改变。所有的状态都需要显式的指定，比如没有默认的颜色混合状态。

好消息是你相当于进行预编译(ahead-of-time compilation)而不是即时编译(just-in-time compilation)，驱动能够有更多的优化机会，运行时的性能也更有预见性。因为像是切换到不同渲染管线这样大的状态变化非常的明显。

### Step 7 - Command pools and command buffers
### 步骤 7 - 命令池和命令缓冲

早先提到过，Vulkan中我们想要执行的许多操作，像是绘制，需要提交到队列。这些操作在提交之前首先需要记录到一个VkCommandBuffer。这些命令缓冲从与特定队列家族关联的VkCommandPool里分配。要绘制一个简单的三角形，我们需要记录以下操作：

* 开始渲染阶段
* 绑定渲染管线
* 绘制3个顶点
* 结束渲染阶段

因为帧缓冲中的图像是哪个(color, depth, stencil)取决于交换链，我们需要为每个可能的图像记录一个命令缓冲，并在绘制时选择正确的那个。

### Step 8 - Main loop

### 步骤8 - 主循环

齐活了，我们现在需要使用vkAcquireNextImageKHR从交换链获取一张图像，然后为它选择合适的命令缓冲并通过vkQueueSubmit执行。最终我们通过vkQueuePresentKHR将图像还给交换链。

提交给度列的操作同步的执行。因此我们需要用信号量这类同步对象来保证正确的执行顺序。绘制命令缓冲的执行必须等到图像获取完成，否则可能发生我们渲染到一个正在被读取并显示到屏幕的图像这种事。反过来vkQueuePresentKHR需要等待渲染完成，我们需要使用第二个信号量，在渲染完成的时候触发。

## Summary

## 总结

这场旋风之旅应该让你对绘制三角形之前要做的工作了有了一个感性的认识。一个真实世界的程序包含更多的步骤，比如分配顶点缓冲，创建uniform缓冲和更新纹理，将会在后面的章节讲到，不过我们会从简单的开始，因为Vulkan具有足够陡峭的学习曲线。注意一开始我们会做点弊，将顶点坐标嵌入Vertex Shader而不是使用顶点缓冲，因为管理顶点缓冲需要先熟悉命令缓冲。

简而言之，要绘制第一个三角形我们要做的是：

* 创建一个VkInstance
* 选择一个支持的显卡(VkPhysicalDevice)
* 创建一个VkDevice和VkQueue用于绘制和呈现
* 创建一个窗口，窗口表面和交换链
* 将交换链图像包装到VkImageView
* 创建一个渲染阶段指定渲染目标和用途
* 为渲染阶段创建帧缓冲
* 设置图形管线
* 分配命令缓冲，为所有可能的交换链图像记录绘制命令
* 获取图像，提交正确的绘制命令，返还图像给交换链，一帧绘制完成

## API Concepts

## API概念

这一章在较低层次总结一下Vulkan API是如何组织的。

### Code conventions

### 代码规范

所有的Vulkan函数，枚举和结构体都在vulkan.h中定义，包含在LunarG的Vulkan SDK中。

函数带有小写的vk前缀，枚举类型和结构体带有Vk前缀，枚举值带有VK_前缀。API大量使用结构体为函数传递参数。举例来说，对象的创建遵循以下的模式：

```c++
VkXXXCreateInfo createInfo = {};
createInfo.sType = VK_STRUCTURE_TYPE_XXX_CREATE_INFO;
createInfo.pNext = nullptr;
createInfo.foo = ...;
createInfo.bar = ...;

VkXXX object;
if (vkCreateXXX(&createInfo, nullptr, &object) != VK_SUCCESS) {
    std::cerr << "failed to create object" << std::endl;
    return false;
}
```



Vulkan中的许多结构体需要你显式指定sType成员。pNext用于扩展结构体，本教程中一律为nullptr。创建和销毁对象的函数的VkAllocationCallbacks参数允许你使用自定义的内存分配器，本教程也一律为nullptr。

### Validation layers

### 验证层

如前所述，Vulkan被设计为高性能，低驱动消耗。因此它默认包含非常有限的错误检测和调试功能。如果你不小心弄错了什么，驱动会经常性的崩溃而不是返回错误码，或者更糟，只能在你的显卡上运行。

Vulkan允许你使用称为验证层(validation layer)的特性来开启这类检测。验证层是一段段能够插入API之间的代码，由驱动来对函数参数进行额外的检测以及追踪内存管理问题。很棒的一点是你能够在开发期间开启它，然后在发布程序之前完全关闭它以获得零消耗。任何人都可以写自己的验证层，不过本教程会使用LunarG提供的Vulkan SDK中包含的标准验证层集合。你还需要注册一个回调函数来从验证层获得调试信息。

因为Vulkan的每个操作是如此严谨以及验证层是如此泛用，实际上要找到图形绘制问题比OpenGL和Direct3D要来得更容易！

